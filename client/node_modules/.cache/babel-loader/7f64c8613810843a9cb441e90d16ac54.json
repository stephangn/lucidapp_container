{"ast":null,"code":"import _asyncToGenerator from\"/Users/stephan/Dropbox/Entwicklung/webdev/projektstudium/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _regeneratorRuntime from\"/Users/stephan/Dropbox/Entwicklung/webdev/projektstudium/client/node_modules/@babel/runtime/regenerator/index.js\";import axiosInstance from\"../axiosApi\";import{useEffect}from\"react\";import useRefreshToken from\"./useRefreshToken\";import useAuth from\"./useAuth\";//Handler für API Anfragen der Bedarf mittels Interceptor zum Beispiel neuen Acces Token anfragen, den Nutzer zur Anmeldeseite leitet (wenn er nicht mehr eingelogt ist\n//oder die Anfrage durchleitet. \nvar useAxiosPrivate=function useAxiosPrivate(){var refresh=useRefreshToken();var _useAuth=useAuth(),auth=_useAuth.auth;useEffect(function(){//console.log(auth);\n//Wenn kein Token vorhanden ist wird neuer Token erzeugt und gespeichert\nvar requestIntercept=axiosInstance.interceptors.request.use(function(config){if(!config.headers['Authorization']){//console.log(\"Alternativer Header wird erzeugt\");\nconfig.headers['Authorization']=\"Bearer \".concat(auth===null||auth===void 0?void 0:auth.accessToken);}return config;},function(error){return Promise.reject(error);});var responseIntercept=axiosInstance.interceptors.response.use(//Antwort weiterleiten wenn alles okay \nfunction(response){return response;},/*#__PURE__*/ //fehler abfangen und vorherige Anfrage einlesen\nfunction(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(error){var _error$response;var prevRequest,newAccessToken;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0://console.log(\"Fehler in der Anfrage\")\nprevRequest=error===null||error===void 0?void 0:error.config;if(!((error===null||error===void 0?void 0:(_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===401&&!(prevRequest!==null&&prevRequest!==void 0&&prevRequest.sent))){_context.next=8;break;}prevRequest.sent=true;_context.next=5;return refresh();case 5:newAccessToken=_context.sent;prevRequest.headers['Authorization']=\"Bearer \".concat(newAccessToken);return _context.abrupt(\"return\",axiosInstance(prevRequest));case 8:return _context.abrupt(\"return\",Promise.reject(error));case 9:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}());//console.log('interceptors ausgeführt')\n//Cleanup -> um schleifen zu vermeiden \nreturn function(){axiosInstance.interceptors.request.eject(requestIntercept);axiosInstance.interceptors.response.eject(responseIntercept);};},[auth,refresh]);//zurückgeben des Axios Call mit Interceptor\nreturn axiosInstance;};export default useAxiosPrivate;","map":{"version":3,"sources":["/Users/stephan/Dropbox/Entwicklung/webdev/projektstudium/client/src/hooks/useAxiosPrivate.js"],"names":["axiosInstance","useEffect","useRefreshToken","useAuth","useAxiosPrivate","refresh","auth","requestIntercept","interceptors","request","use","config","headers","accessToken","error","Promise","reject","responseIntercept","response","prevRequest","status","sent","newAccessToken","eject"],"mappings":"6SAAA,MAAOA,CAAAA,aAAP,KAA0B,aAA1B,CACA,OAASC,SAAT,KAA0B,OAA1B,CACA,MAAOC,CAAAA,eAAP,KAA4B,mBAA5B,CACA,MAAOC,CAAAA,OAAP,KAAoB,WAApB,CAIA;AACA;AAEA,GAAMC,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,EAAM,CAC1B,GAAMC,CAAAA,OAAO,CAAGH,eAAe,EAA/B,CACA,aAAiBC,OAAO,EAAxB,CAAQG,IAAR,UAAQA,IAAR,CAGAL,SAAS,CAAC,UAAM,CACZ;AAEA;AACA,GAAMM,CAAAA,gBAAgB,CAAGP,aAAa,CAACQ,YAAd,CAA2BC,OAA3B,CAAmCC,GAAnC,CACrB,SAAAC,MAAM,CAAI,CACN,GAAI,CAACA,MAAM,CAACC,OAAP,CAAe,eAAf,CAAL,CAAsC,CAClC;AACAD,MAAM,CAACC,OAAP,CAAe,eAAf,mBAA4CN,IAA5C,SAA4CA,IAA5C,iBAA4CA,IAAI,CAAEO,WAAlD,EACH,CACD,MAAOF,CAAAA,MAAP,CACH,CAPoB,CAOlB,SAACG,KAAD,QAAWC,CAAAA,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAX,EAPkB,CAAzB,CASA,GAAMG,CAAAA,iBAAiB,CAAGjB,aAAa,CAACQ,YAAd,CAA2BU,QAA3B,CAAoCR,GAApC,CACtB;AACA,SAAAQ,QAAQ,QAAIA,CAAAA,QAAJ,EAFc,eAGtB;AAHsB,4EAItB,iBAAOJ,KAAP,qKACI;AACMK,WAFV,CAEwBL,KAFxB,SAEwBA,KAFxB,iBAEwBA,KAAK,CAAEH,MAF/B,MAGQ,CAAAG,KAAK,OAAL,EAAAA,KAAK,SAAL,yBAAAA,KAAK,CAAEI,QAAP,0DAAiBE,MAAjB,IAA4B,GAA5B,EAAmC,EAACD,WAAD,SAACA,WAAD,WAACA,WAAW,CAAEE,IAAd,CAH3C,0BAIQF,WAAW,CAACE,IAAZ,CAAmB,IAAnB,CAJR,sBAKqChB,CAAAA,OAAO,EAL5C,QAKciB,cALd,eAMQH,WAAW,CAACP,OAAZ,CAAoB,eAApB,mBAAiDU,cAAjD,EANR,gCAOetB,aAAa,CAACmB,WAAD,CAP5B,yCASWJ,OAAO,CAACC,MAAR,CAAeF,KAAf,CATX,wDAJsB,+DAA1B,CAiBA;AACA;AACA,MAAM,WAAM,CACRd,aAAa,CAACQ,YAAd,CAA2BC,OAA3B,CAAmCc,KAAnC,CAAyChB,gBAAzC,EACAP,aAAa,CAACQ,YAAd,CAA2BU,QAA3B,CAAoCK,KAApC,CAA0CN,iBAA1C,EAEH,CAJD,CAKH,CArCQ,CAqCN,CAACX,IAAD,CAAMD,OAAN,CArCM,CAAT,CAsCA;AACA,MAAOL,CAAAA,aAAP,CAEH,CA9CD,CAgDA,cAAeI,CAAAA,eAAf","sourcesContent":["import axiosInstance from \"../axiosApi\";\nimport { useEffect } from \"react\";\nimport useRefreshToken from \"./useRefreshToken\";\nimport useAuth from \"./useAuth\";\n\n\n\n//Handler für API Anfragen der Bedarf mittels Interceptor zum Beispiel neuen Acces Token anfragen, den Nutzer zur Anmeldeseite leitet (wenn er nicht mehr eingelogt ist\n//oder die Anfrage durchleitet. \n\nconst useAxiosPrivate = () => {\n    const refresh = useRefreshToken();\n    const { auth } = useAuth();\n\n\n    useEffect(() => {\n        //console.log(auth);\n\n        //Wenn kein Token vorhanden ist wird neuer Token erzeugt und gespeichert\n        const requestIntercept = axiosInstance.interceptors.request.use(\n            config => {\n                if (!config.headers['Authorization']) {\n                    //console.log(\"Alternativer Header wird erzeugt\");\n                    config.headers['Authorization'] = `Bearer ${auth?.accessToken}`;\n                }\n                return config;\n            }, (error) => Promise.reject(error)\n        ); \n        const responseIntercept = axiosInstance.interceptors.response.use(\n            //Antwort weiterleiten wenn alles okay \n            response => response,\n            //fehler abfangen und vorherige Anfrage einlesen\n            async (error) => {\n                //console.log(\"Fehler in der Anfrage\")\n                const prevRequest = error?.config;\n                if (error?.response?.status === 401 && !prevRequest?.sent) {\n                    prevRequest.sent = true;\n                    const newAccessToken = await refresh();\n                    prevRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;\n                    return axiosInstance(prevRequest); \n                }\n                return Promise.reject(error);\n            }\n            \n        );\n        //console.log('interceptors ausgeführt')\n        //Cleanup -> um schleifen zu vermeiden \n        return() => {\n            axiosInstance.interceptors.request.eject(requestIntercept)\n            axiosInstance.interceptors.response.eject(responseIntercept)\n\n        }\n    }, [auth,refresh])\n    //zurückgeben des Axios Call mit Interceptor\n    return axiosInstance\n\n}\n\nexport default useAxiosPrivate"]},"metadata":{},"sourceType":"module"}